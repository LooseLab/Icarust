syntax="proto3";

package minknow_api.manager;

option java_package = "com.nanoporetech.minknow_api";
option objc_class_prefix = "MKAPI";

import "minknow_api/instance.proto";

service ManagerService {
    // Get information about the machine running MinKNOW.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.6
    rpc describe_host (DescribeHostRequest) returns (DescribeHostResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

        // List all known positions where flow cells can be inserted.
    //
    // Provides a snapshot of places where users can insert flow cells. It has a streamed response
    // in case there are too many positions to fit into a single response, but normally there should
    // only be a single response.
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // Since 3.6
    rpc flow_cell_positions (FlowCellPositionsRequest) returns (stream FlowCellPositionsResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // Current version information includes:
    // - Minknow version
    // - Protocols version (i.e. Bream-4 version)
    // - Configuration version (i.e. Wanda version)
    // - Distribution version
    // - Guppy version
    //
    // This RPC can be called without providing any authentication tokens.
    //
    // See also: instance.get_version_info which provides some similar information on a per instance basis.
    // Since 3.3
    rpc get_version_info (GetVersionInfoRequest) returns (GetVersionInfoResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }
}

message DescribeHostResponse {
    // The product code for the host, if applicable.
    //
    // If this is an integrated Oxford Nanopore device, this will be the product code of the device,
    // or the part of the device that runs MinKNOW (eg: several PromethION models have separate
    // product codes for the sequencing unit where the flow cells are inserted and the compute
    // unit - this would be the product code for the compute unit).
    //
    // Some example product codes:
    //
    // ============  =================
    // Product Code  Name
    // ============  =================
    // GRD-X5B001    GridION X5
    // GRD-X5B002    GridION X5
    // GRD-X5B003    GridION X5 Mk1
    // MIN-101B      MinIT
    // MIN-101C      MinION Mk1C
    // PRO-PRMC01    PromethION Beta
    // PRO-PRC024    PromethION 24
    // PRO-PRC048    PromethION 48
    // ONT-314       PromethION (Production)
    //
    // If MinKNOW is running on a machine that is not provided by Oxford Nanopore (ie: their own
    // laptop or desktop machine with a MinION plugged in), this field will be empty.
    string product_code = 1;

    // A human-readable name for the type of host.
    //
    // If `product_code` is set, it will be the name of the model of instrument (see the table in
    // the `product_code` field). Otherwise it will be empty.
    string description = 2;

    // The serial of Nanopore device.
    //
    // If `product_code` is empty, this will also be empty.
    //
    // This uniquely identifies the device.
    //
    // See also `network_name`.
    string serial = 3;

    // The network name of the host.
    //
    // This is the name the host system believes it has on the network. This can be useful if an IP
    // address was used to connect to the RPC system.
    //
    // For customer computers, this is the only available identfying information for the system.
    string network_name = 4;

    // This device has not been associated with an account.
    //
    // Association must be completed before using the device.
    //
    // Note that this will only ever be set for hosts that also have a `product_code` and `serial`.
    //
    // If this is true, all positions will report as ``STATE_NEEDS_ASSOCIATION`` until the device
    // is associated. Even if this is false, however, removable sequencing units (eg: the MinION
    // Mk1B) may require their own association (in which case they will individually report as
    // ``STATE_NEEDS_ASSOCIATION`` - see the `flow_cell_positions` RPC).
    //
    // Since 4.4
    bool needs_association = 16;

    // Whether the device can sequence while offline.
    //
    // Not all sequencing devices can sequence without an internet connection. This indicates
    // whether it is possible for the integrated sequencing positions. Note that this will only be
    // set if `needs_association` is true.
    //
    // Since 4.4
    bool can_sequence_offline = 5;
}

message DescribeHostRequest {
}

message FlowCellPosition {
    // The name of the position.
    //
    // For MinIONs, this is the name of the MinION (eg: MN12345). For integrated positions, this is
    // the label for the position on the sequencer (eg: X1 for GridION, 1-A1-D1 for PromethION).
    string name = 1;

    message Location {
        // The column (counting from 0, left-to-right) of the flow cell position on the sequencing
        // unit when viewed from above/in front.
        int32 x = 1;

        // The row (counting from 0, top-to-bottom) of the flow cell position on the sequencing
        // unit when viewed from above/in front.
        int32 y = 2;
    }
    // For integrated flow cell positions, indicates where it is on the sequencing unit.
    //
    // This information is not provided for MinIONs (except for the MinION Mk1C, in which case the
    // position is always 0, 0).
    Location location = 2;

    enum State {
        // The flow cell position is being initialised. This state should only last for a few
        // seconds, before moving to `STATE_RUNNING` or one of the error states.
        STATE_INITIALISING = 0;
        // The flow cell position is in a basic state of operation, and an RPC interface is
        // available for it.
        //
        // `rpc_ports` is guaranteed to be set in this tate. Note that port information may also be
        // provided in the hardware error states if the software is still running.
        //
        // Note that many hardware and software errors are not detectable by the manager, so
        // `STATE_RUNNING` may be set even when there is a problem. The interface provided over
        // `rpc_ports` should be the canonical source of the state of the flow cell position when in
        // `STATE_RUNNING`. In the future, more errors may be tracked properly here.
        STATE_RUNNING = 1;
        // After calling reset_position(), this state may be entered to indicate the software is in
        // the process of being stopped.
        //
        // Typically, this state will either transition into STATE_INITIALISING or the position will
        // be removed entirely (although it could return to one of the hardware error states).
        STATE_RESETTING = 2;
        // The hardware corresponding to the flow cell position was removed.
        //
        // Only set for removable positions (ie: USB MinIONs). This state indicates that the
        // hardware was removed, but the software is still running. The software will not be stopped
        // automatically to prevent possible data loss. Call reset_position() to stop the software
        // and forget about the position.
        STATE_HARDWARE_REMOVED = 3;
        // Communication with the hardware failed.
        //
        // For integrated positions, this can include when the hardware was not found at all (eg: if
        // a PromethION has not had one of its sequencing unit cables attached).
        //
        // More information may be available in `error_info`.
        STATE_HARDWARE_ERROR = 4;
        // The software corresponding to the flow cell position could not be started (or stopped
        // unexpectedly).
        //
        // More information may be available in `error_info`.
        STATE_SOFTWARE_ERROR = 5;
        // The position is not available because it requires association.
        //
        // See also `DescribeHostResponse.needs_association`. If the `describe_host` RPC result has
        // `needs_association` set to false, this position is a pluggable device (likely a MinION
        // Mk1B) that individually requires assocation.
        //
        // Since 4.4
        STATE_NEEDS_ASSOCIATION = 6;
    };
    // The state of the flow cell position.
    //
    // If the state is not `STATE_RUNNING` or `STATE_INITIALISING`, the flow cell position can be
    // assumed to be unusable, and the `error_info` field should be populated.
    State state = 3;

    message RpcPorts {
        // A port providing the standard gRPC protocol over TLS
        uint32 secure = 1;
        // A port providing the standard gRPC protocol without TLS
        uint32 insecure = 2;
        // A port providing the gRPC-Web protocol over TLS
        uint32 secure_grpc_web = 3;
        // DEPRECATED: A port providing the gRPC-Web protocol without TLS
        //
        // From 4.1, this field is now deprecated and will only ever
        // return a value of 0
        uint32 insecure_grpc_web = 4;
    }
    // The ports the APIs for this flow cell position are provided on.
    //
    // Always provided if `state` is `STATE_RUNNING`. May also be provided when `state` is one of
    // the hardware errors if the software is still running.
    RpcPorts rpc_ports = 4;

    // Provides a textual description of error states.
    //
    // When `state` is not `STATE_INITIALISING`, `STATE_RUNNING` or `STATE_RESETTING`, this provides
    // some information (in English) about the error. This will be a textual description of the
    // value in `state`, possibly with extra information about the error (if available).
    //
    // This can be useful for dealing with (new) unknown states.
    string error_info = 5;

    message SharedHardwareGroup {
        uint32 group_id = 1;
    }

    // Some positions may share hardware. Positions that share hardware will have the same
    // group-id. If positions do share hardware, to reset the hardware you will need to
    // reset all positions in the group at the same time.
    SharedHardwareGroup shared_hardware_group = 6;

    // Indicates that this is an integrated flow cell position.
    //
    // This is true for the integrated positions on a PromethION, GridION or MinION Mk1C, and false
    // for a MinION Mk1B.
    //
    // Integrated positions are always listed, even if (due to some hardware error) they can't be
    // found. They are never in STATE_HARDWARE_REMOVED, and they always report a location.
    //
    // Additionally, integrated positions cannot be associated independently - if they are in
    // STATE_NEEDS_ASSOCIATION, then the host as a whole needs associating. Likewise, either all
    // integrated positions can run offline, or none of them can.
    //
    // Since 4.4
    bool is_integrated = 7;

    // Indicates that this position can sequence offline.
    //
    // For integrated positions, this is the same as the corresponding field returned from the
    // describe_host RPC.
    bool can_sequence_offline = 8;
}

message FlowCellPositionsRequest {
}

message FlowCellPositionsResponse {
    // How many positions are available in total.
    //
    // This is the same in every message returned from a single call, and allows the caller to
    // easily see how many further positions might be in subsequent messages.
    int32 total_count = 1;

    // Known flow cell positions.
    //
    // Note that not all positions listed here are necessarily available. In particular, integrated
    // flow cell positions (eg: on GridIONs or PromethIONs) will always be listed.
    repeated FlowCellPosition positions = 2;
}

message GetVersionInfoRequest {}

message GetVersionInfoResponse {

    // Note that InstallationType is duplicated in instance.proto, the two definitions should be kept in sync.
    enum InstallationType {
        // For internal release. production.proto will be enabled for this type
        ONT = 0;

        // For customer releases
        NC = 1;

        // For production release. production.proto will be enabled for this type
        PROD = 2;

        // For Q releases (nanopore long term support release)
        Q_RELEASE = 3;

        // Oxford Nanopore Diagnostic
        OND_RELEASE = 4;
    }


    // What minknow version is installed. Split into major, minor and patch versions
    // Also includes the full version as a string, which contain the major, minor and patch numbers
    // as well as if the version is pre-release version (-pre), whether it is a release candidate (-rc#)
    // or whether it is a variant version (i.e. for conferences) (-variant). For non-release builds it also
    // includes the hash of the commit it is based on, and whether the working copy is different from that has (-dirty)
    instance.GetVersionInfoResponse.MinknowVersion minknow = 1;

    // The protocols version specifies what version of bream is installed.
    // By default is set to '0.0.0.0', but will otherwise be set to a Bream release version.
    string protocols = 2;

    // Describes the distribution that this MinKNOW installation is part of, ususally
    // this will be the Metapackage version number/identity, this will be "unknown"
    // if the distribution-version hasn't been set. This information is also communicated
    // in the Manager's DaemonMessage in daemon.proto
    string distribution_version = 3;

    // Indicates if the MinKNOW distribution including components such as Bream
    // are stable, unstable or have been modified.
    instance.GetVersionInfoResponse.DistributionStatus distribution_status = 4;

    // Version of guppy MinKNOW was packaged against.
    string guppy_build_version = 5;

    // Version of guppy MinKNOW running with.
    string guppy_connected_version = 6;

    // The configuration version specifies what version of ont-configuration (wanda) is installed.
    // By default is set to '0.0.0.0', but will otherwise be set to a Wanda release version.
    //
    // Since 3.6
    string configuration = 7;

    // Indicates what installation type minknow was installed as. Certain installation
    // types may turn features on or off depending on the type. For example,
    // for ont and prod installs, the production.proto service will be enabled
    // to make calls such as writing to the eeprom
    InstallationType installation_type = 8;
}